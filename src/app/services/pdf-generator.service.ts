import { Injectable } from '@angular/core';
import type { Work, WorkLanguageSelection } from '../../models/work.model';
import type { RightsHolder } from './rights-holder';
import type { WorkSplitRow } from '../split-editor/split-editor';

interface PdfSectionStyle {
  accent: string;
  accentText: string;
  headerFill: string;
  headerText: string;
}

/**
 * PDF Generation Service
 * Produces protocol-ready documentation for works and their splits
 */
@Injectable({ providedIn: 'root' })
export class PdfGeneratorService {
  /**
   * Generate the protocol PDF blob with enriched metadata
   */
  async generateProtocolPDF(
    work: Work,
    ipSplits: WorkSplitRow[],
    neighboringSplits: WorkSplitRow[]
  ): Promise<Blob> {
    const { jsPDF } = await import('jspdf');

    const doc = new jsPDF({ unit: 'pt', format: 'a4' });
    const margin = 48;
    const pageWidth = doc.internal.pageSize.getWidth();
    const pageHeight = doc.internal.pageSize.getHeight();
    let y = margin;

    const sectionStyles: {
      overview: PdfSectionStyle;
      metadata: PdfSectionStyle;
      ai: PdfSectionStyle;
      ip: PdfSectionStyle;
      neighbouring: PdfSectionStyle;
      signatures: PdfSectionStyle;
    } = {
      overview: {
        accent: '#4338ca',
        accentText: '#ffffff',
        headerFill: '#e0e7ff',
        headerText: '#1e3a8a',
      },
      metadata: {
        accent: '#2563eb',
        accentText: '#ffffff',
        headerFill: '#dbeafe',
        headerText: '#1d4ed8',
      },
      ai: {
        accent: '#d97706',
        accentText: '#ffffff',
        headerFill: '#fef3c7',
        headerText: '#92400e',
      },
      ip: {
        accent: '#7c3aed',
        accentText: '#ffffff',
        headerFill: '#ede9fe',
        headerText: '#5b21b6',
      },
      neighbouring: {
        accent: '#0f766e',
        accentText: '#ffffff',
        headerFill: '#ccfbf1',
        headerText: '#0f766e',
      },
      signatures: {
        accent: '#374151',
        accentText: '#ffffff',
        headerFill: '#e5e7eb',
        headerText: '#111827',
      },
    };

    const generatedAt = new Date();
    const isRemixWork = work.work_type === 'remix';

    const ensureSpace = (height: number) => {
      if (y + height > pageHeight - margin) {
        doc.addPage();
        y = margin;
      }
    };

    const setBodyFont = () => {
      doc.setFont('helvetica', 'normal');
      doc.setFontSize(10);
      doc.setTextColor('#1a1a1a');
    };

    const drawTitle = () => {
      doc.setFont('helvetica', 'bold');
      doc.setFontSize(22);
      doc.setTextColor('#1a1a1a');
      // Compose the main title: release_title (if present), else work_title, else first alternative title, then 'Split Sheet'
      let mainTitle = work.release_title?.trim()
        || work.work_title?.trim()
        || (work.alternative_titles && work.alternative_titles[0])
        || 'Untitled Work';
      if (work.alternative_titles && work.alternative_titles.length > 1) {
        mainTitle += ` (${work.alternative_titles.slice(1).join(', ')})`;
      }
      doc.text(this.safeText(mainTitle + ' Split Sheet'), margin, y);
      y += 26;

      doc.setFont('helvetica', 'normal');
      doc.setFontSize(12);
      // Optionally show all titles if available (excluding main title)
      if (work.release_title && mainTitle !== work.release_title) {
        doc.text('Release title: ' + this.safeText(work.release_title), margin, y);
        y += 14;
      }
      if (work.work_title && mainTitle !== work.work_title) {
        doc.text('Work title: ' + this.safeText(work.work_title), margin, y);
        y += 14;
      }
      if (work.alternative_titles && work.alternative_titles.length) {
        doc.text('Alternative titles: ' + this.safeText(work.alternative_titles.join(', ')), margin, y);
        y += 14;
      }

      doc.setFontSize(10);
      doc.setTextColor('#555555');
      const generatedStamp = `Generated ${generatedAt.toLocaleString()}`;
      const identifiers = [`Work ID: ${work.id}`, `Workspace: ${work.workspace_id}`];
      doc.text(generatedStamp, margin, y);
      y += 14;
      doc.text(identifiers.join('  •  '), margin, y);
      y += 24;
      setBodyFont();
    };

    const addFooters = () => {
      const pageCount = doc.getNumberOfPages();
      const footerStamp = generatedAt.toLocaleString();
      for (let i = 1; i <= pageCount; i++) {
        doc.setPage(i);
        const footerText = `Page ${i}` +
          `\nGenerated by Music Rights Platform · ${footerStamp} ]]Protocol Reference: b438c8fb-8b15-47e1-acbc-d717be069506`;
        doc.setFont('helvetica', 'normal');
        doc.setFontSize(8);
        doc.setTextColor('#888888');
        doc.text(footerText, margin, doc.internal.pageSize.getHeight() - 24, {
          maxWidth: doc.internal.pageSize.getWidth() - margin * 2
        });
      }
    };

    const drawSectionTitle = (title: string, style: PdfSectionStyle) => {
      const blockHeight = 32;
      ensureSpace(blockHeight + 12);

      doc.setFillColor(style.accent);
      doc.setDrawColor(style.accent);
      doc.roundedRect(margin, y, pageWidth - margin * 2, blockHeight, 8, 8, 'F');

      doc.setFont('helvetica', 'bold');
      doc.setFontSize(14);
      doc.setTextColor(style.accentText);
      doc.text(title, margin + 16, y + 20);

      y += blockHeight + 12;
      setBodyFont();
    };

    const drawKeyValueGrid = (items: Array<{ label: string; value: string }>) => {
      if (!items.length) return;

      const columnWidth = (pageWidth - margin * 2) / 2;

      for (let i = 0; i < items.length; i += 2) {
        const first = items[i];
        const second = items[i + 1];
        const rowY = y;
        let rowHeight = 0;

        if (first) {
          const height = drawKeyValueItem(first, margin, columnWidth, rowY);
          rowHeight = Math.max(rowHeight, height);
        }

        if (second) {
          const height = drawKeyValueItem(second, margin + columnWidth, columnWidth, rowY);
          rowHeight = Math.max(rowHeight, height);
        }

        rowHeight = Math.max(rowHeight, 24);
        ensureSpace(rowHeight + 4);
        y = rowY + rowHeight + 6;
      }
    };

    const drawKeyValueItem = (
      item: { label: string; value: string },
      x: number,
      width: number,
      baseY: number
    ): number => {
      doc.setFont('helvetica', 'bold');
      doc.setFontSize(10);
      doc.text(item.label, x, baseY);
      setBodyFont();
      const safeValue = this.safeText(item.value || '—');
      const lines = doc.splitTextToSize(safeValue, width - 12);
      doc.text(lines, x, baseY + 14);
      const lineCount = Math.max(lines.length, 1);
      return 14 + lineCount * 12;
    };

    const drawParagraph = (text: string) => {
      if (!text) return;
      const lines = doc.splitTextToSize(this.safeText(text), pageWidth - margin * 2);
      ensureSpace(lines.length * 12 + 4);
      doc.text(lines, margin, y);
      y += lines.length * 12 + 6;
    };

    const drawProductionMetadata = () => {
      const items: Array<{ label: string; value: string }> = [];

      if (typeof work.is_100_percent_human === 'boolean') {
        items.push({
          label: 'Creation Process',
          value: work.is_100_percent_human ? '100% human created' : 'Includes assisted or automated elements',
        });
      }

      if (typeof work.uses_sample_libraries === 'boolean') {
        items.push({ label: 'Sample Libraries Used', value: this.formatBoolean(work.uses_sample_libraries) });
      }

      if (typeof work.has_commercial_license === 'boolean') {
        items.push({ label: 'Commercial License Secured', value: this.formatBoolean(work.has_commercial_license) });
      }

      if (!items.length && !work.sample_library_names) {
        return;
      }

      drawSectionTitle('Production Metadata', sectionStyles.metadata);

      if (items.length) {
        drawKeyValueGrid(items);
      } else {
        drawParagraph('No production metadata recorded.');
      }

      if (work.sample_library_names) {
        drawParagraph(`Sample Libraries: ${this.safeText(work.sample_library_names)}`);
      }
    };

    const drawSourceWorks = () => {
      const sources = work.original_works && work.original_works.length ? work.original_works : null;

      if (!sources && !isRemixWork) {
        return;
      }

      const sectionLabel = isRemixWork ? 'Source Works (Remix)' : 'Referenced Works';
      drawSectionTitle(sectionLabel, sectionStyles.metadata);

      if (!sources) {
        drawParagraph('No source works documented for this remix yet.');
        return;
      }

      sources.forEach((original, index) => {
        const heading = original.title ? `${index + 1}. ${original.title}` : `Source Work ${index + 1}`;
        doc.setFont('helvetica', 'bold');
        doc.setFontSize(11);
        ensureSpace(18);
        doc.text(this.safeText(heading), margin, y);
        y += 14;
        setBodyFont();

        const details: Array<{ label: string; value: string }> = [];
        if (original.isrc) {
          details.push({ label: 'ISRC', value: original.isrc });
        }
        if (original.iswc) {
          details.push({ label: 'ISWC', value: original.iswc });
        }

        if (details.length) {
          drawKeyValueGrid(details);
        }

        if (original.additional_info) {
          drawParagraph(`Notes: ${original.additional_info}`);
        }

        y += 4;
      });
    };

    const drawAIDisclosures = () => {
      drawSectionTitle('AI Disclosures', sectionStyles.ai);

      if (!work.ai_disclosures || !work.ai_disclosures.length) {
        drawParagraph('No AI disclosures recorded for this work.');
        return;
      }

      work.ai_disclosures.forEach(disclosure => {
        const sectionLabel = this.formatSectionLabel(disclosure.section);
        const typeLabel = this.formatCreationType(disclosure.creation_type);
        const details: string[] = [
          `• ${sectionLabel}: ${typeLabel}`,
        ];

        if (disclosure.ai_tool) {
          details.push(`Tool: ${disclosure.ai_tool}`);
        }

        if (disclosure.notes) {
          details.push(disclosure.notes);
        }

        drawParagraph(details.join(' – '));
      });
    };

    const drawContributorTable = (
      title: string,
      rows: Array<[string, string, string, string, string]>,
      totalShare: number,
      emptyMessage: string,
      style: PdfSectionStyle
    ) => {
      drawSectionTitle(title, style);

      if (!rows.length) {
        drawParagraph(emptyMessage);
        return;
      }

      const columnWidths = [160, 90, 90, 60, pageWidth - margin * 2 - 400];
      const headers = ['Rights Holder', 'Role', 'Split', 'Share', 'Details'];

      ensureSpace(26);
      doc.setFillColor(style.headerFill);
      doc.rect(margin, y - 12, pageWidth - margin * 2, 26, 'F');
      doc.setFont('helvetica', 'bold');
      doc.setFontSize(10);
      doc.setTextColor(style.headerText);

      let headerX = margin;
      headers.forEach((header, index) => {
        doc.text(header, headerX + 8, y + 4);
        headerX += columnWidths[index];
      });

      y += 26;
      setBodyFont();

      rows.forEach((row, rowIndex) => {
        const cellLines = row.map((value, index) =>
          doc.splitTextToSize(this.safeText(value || '—'), columnWidths[index] - 16)
        );

        const rowHeight = Math.max(...cellLines.map(lines => Math.max(lines.length, 1))) * 12 + 6;
        ensureSpace(rowHeight + 6);

        if (rowIndex % 2 === 0) {
          doc.setFillColor('#fafafa');
          doc.rect(margin, y - 10, pageWidth - margin * 2, rowHeight + 10, 'F');
        }

        let cellX = margin;
        row.forEach((value, colIndex) => {
          const lines = cellLines[colIndex];
          doc.text(lines, cellX + 8, y + 2);
          cellX += columnWidths[colIndex];
        });

        y += rowHeight + 10;
      });

      ensureSpace(30);
      doc.setFillColor(style.accent);
      doc.setTextColor(style.accentText);
      doc.rect(margin, y - 12, pageWidth - margin * 2, 26, 'F');
      doc.text('Total Share', margin + 8, y + 4);
      doc.text(`${totalShare.toFixed(2)}%`, margin + columnWidths[0] + columnWidths[1] + columnWidths[2] + 8, y + 4);
      doc.setTextColor('#1a1a1a');
      y += 32;
    };

    const drawSignatures = (holders: RightsHolder[]) => {
      if (!holders.length) {
        return;
      }

      doc.addPage();
      y = margin;
      drawSectionTitle('Signatures', sectionStyles.signatures);
      drawParagraph('Each contributor confirms the distribution of rights documented in this protocol.');

      doc.setDrawColor('#d0d0d0');
      holders.slice(0, 8).forEach(holder => {
        ensureSpace(64);
        const holderName = this.getRightsHolderName(holder);
        doc.line(margin, y, margin + 250, y);
        doc.line(margin + 300, y, margin + 520, y);
        doc.setFont('helvetica', 'bold');
        doc.setFontSize(10);
        doc.text('Signature', margin, y + 14);
        doc.text('Date', margin + 300, y + 14);
        setBodyFont();
        doc.text(holderName, margin, y + 30);
        const contact = this.buildContactSummary(holder);
        if (contact) {
          doc.text(contact, margin, y + 42);
        }
        y += 54;
      });
    };

    drawTitle();
    // ...rest of PDF generation logic...

    const languageSummary = this.buildLanguageSummary(work);

    drawSectionTitle('Work Overview', sectionStyles.overview);
    drawKeyValueGrid([
      { label: 'Status', value: this.formatStatus(work.status) },
      { label: 'Genre', value: work.genre || '—' },
      { label: 'Work Type', value: this.formatWorkType(work.work_type) },
      { label: 'Primary Languages', value: languageSummary.primary },
      { label: 'Duration', value: this.formatDuration(work.duration_seconds) },
      { label: 'Secondary Languages', value: languageSummary.secondary },
      { label: 'Alternative Titles', value: this.formatList(work.alternative_titles) },
      { label: 'All Languages', value: languageSummary.combined },
      { label: 'Catalogue Number', value: work.catalog_number || '—' },
      { label: 'EAN', value: work.ean || '—' },
      { label: 'Created At', value: this.formatDate(work.created_at) },
      { label: 'Updated At', value: this.formatDate(work.updated_at) },
    ]);

    if (work.notes) {
      drawParagraph(`Notes: ${work.notes}`);
    }

    drawSectionTitle('Identification Codes', sectionStyles.metadata);
    drawKeyValueGrid([
      { label: 'ISRC', value: work.isrc || '—' },
      { label: 'ISWC', value: work.iswc || '—' },
    ]);

    drawSectionTitle('Release Details', sectionStyles.metadata);
    drawKeyValueGrid([
      { label: 'Recording Date', value: this.formatDate(work.recording_date) },
      { label: 'Release Date', value: this.formatDate(work.release_date) },
      { label: 'Cover Version', value: work.is_cover_version ? 'Yes' : 'No' },
    ]);

    if (work.is_cover_version) {
      drawKeyValueGrid([
        { label: 'Original Work Title', value: work.original_work_title || '—' },
        { label: 'Original Work ISRC', value: work.original_work_isrc || '—' },
        { label: 'Original Work ISWC', value: work.original_work_iswc || '—' },
      ]);
      if (work.original_work_info) {
        drawParagraph(`Original Work Info: ${work.original_work_info}`);
      }
    }

    drawProductionMetadata();
    drawSourceWorks();

    drawAIDisclosures();

    const ipSummary = this.buildIPSummary(work, ipSplits);
    drawSectionTitle('Intellectual Property Summary', sectionStyles.ip);
    drawKeyValueGrid([
      {
        label: 'Lyric Contributors',
        value: ipSummary.lyricsApplicable
          ? String(ipSummary.lyricsCount)
          : 'Not applicable (instrumental work)',
      },
      { label: 'Music Contributors', value: String(ipSummary.musicCount) },
      {
        label: 'Lyrics Share',
        value: ipSummary.lyricsApplicable ? `${ipSummary.lyricsShare.toFixed(2)}%` : 'Not applicable',
      },
      { label: 'Music Share', value: `${ipSummary.musicShare.toFixed(2)}%` },
      {
        label: 'Combined IP Total',
        value: ipSummary.lyricsApplicable
          ? `${ipSummary.combinedShare.toFixed(2)}%`
          : `${ipSummary.combinedShare.toFixed(2)}% (music only)`,
      },
      { label: 'Split Status', value: ipSummary.statusLabel },
    ]);

    drawContributorTable(
      'Intellectual Property Contributors',
      this.buildIPRows(ipSplits),
      ipSummary.combinedShare,
      'No intellectual property contributors recorded.',
      sectionStyles.ip
    );

    if (!ipSummary.lyricsApplicable) {
      drawParagraph('Instrumental work: Lyrics splits are not required. The totals above reflect music contributions only.');
    }

    if (ipSummary.isIncomplete) {
      drawParagraph('⚠️ Temporary split: Lyrics and/or music allocations are below 100%. Final shares pending.');
    }

    const neighbouringSummary = this.buildNeighbouringSummary(neighboringSplits);
    drawSectionTitle('Neighbouring Rights Summary', sectionStyles.neighbouring);
    drawKeyValueGrid([
      { label: 'Contributors', value: String(neighbouringSummary.count) },
      { label: 'Total Share', value: `${neighbouringSummary.totalShare.toFixed(2)}%` },
      { label: 'Split Status', value: neighbouringSummary.statusLabel },
    ]);

    drawContributorTable(
      'Neighbouring Rights Contributors',
      this.buildNeighbouringRows(neighboringSplits),
      neighbouringSummary.totalShare,
      'No neighbouring rights contributors recorded.',
      sectionStyles.neighbouring
    );

    if (neighbouringSummary.isIncomplete) {
      drawParagraph('⚠️ Temporary split: Neighbouring rights allocations are below 100%. Final shares pending.');
    }

    const uniqueHolders = this.collectUniqueHolders([...ipSplits, ...neighboringSplits]);
    drawSignatures(uniqueHolders);

    doc.setFontSize(9);
    doc.setTextColor('#777777');
    doc.text(
      `Generated by Music Rights Platform · ${new Date().toLocaleDateString()}`,
      margin,
      pageHeight - margin / 2
    );
    const protocolId = `Protocol Reference: ${work.id}`;
    const protocolWidth = doc.getTextWidth(protocolId);
    doc.text(protocolId, pageWidth - margin - protocolWidth, pageHeight - margin / 2);

    addFooters();
    return doc.output('blob');
  }

  /**
   * Backwards compatible entry point for legacy split-sheet calls
   */
  async generateSplitSheetPDF(
    work: Work,
    ipSplits: WorkSplitRow[],
    neighboringSplits: WorkSplitRow[]
  ): Promise<Blob> {
    return this.generateProtocolPDF(work, ipSplits, neighboringSplits);
  }

  /**
   * Download the generated protocol PDF
   */
  async downloadProtocol(
    work: Work,
    ipSplits: WorkSplitRow[],
    neighboringSplits: WorkSplitRow[],
    filename?: string
  ): Promise<void> {
    const pdfBlob = await this.generateProtocolPDF(work, ipSplits, neighboringSplits);
    const url = URL.createObjectURL(pdfBlob);

    try {
      const link = document.createElement('a');
      link.href = url;
      link.download = filename || this.createProtocolFilename(work);
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    } finally {
      URL.revokeObjectURL(url);
    }
  }

  /**
   * Backwards compatible download API
   */
  async downloadSplitSheet(
    filename: string,
    work: Work,
    ipSplits: WorkSplitRow[],
    neighboringSplits: WorkSplitRow[]
  ): Promise<void> {
    await this.downloadProtocol(work, ipSplits, neighboringSplits, filename);
  }

  private buildIPSummary(work: Work, ipSplits: WorkSplitRow[]) {
    const lyricSplits = ipSplits.filter(split => split.split_type === 'lyrics');
    const musicSplits = ipSplits.filter(split => split.split_type === 'music');

    const lyricsShare = lyricSplits.reduce((sum, split) => sum + this.toNumber(split), 0);
    const musicShare = musicSplits.reduce((sum, split) => sum + this.toNumber(split), 0);
    const normalizedLyrics = this.normalizeShare(lyricsShare);
    const normalizedMusic = this.normalizeShare(musicShare);

    const lyricsApplicable = work.work_type !== 'instrumental';
    const combinedShare = lyricsApplicable
      ? Math.min(normalizedLyrics + normalizedMusic, 100)
      : normalizedMusic;

    const tolerance = 0.01;
    const lyricsState = lyricsShare > 100 + tolerance ? 'over' : lyricsShare >= 100 - tolerance ? 'complete' : 'under';
    const musicState = musicShare > 100 + tolerance ? 'over' : musicShare >= 100 - tolerance ? 'complete' : 'under';
    const states = [lyricsState, musicState];
    const hasOver = states.includes('over');
    const hasUnder = states.includes('under');
    const hasEntries = lyricSplits.length > 0 || musicSplits.length > 0;

    let statusLabel: string;

    if (!lyricsApplicable) {
      statusLabel = normalizedMusic >= 100
        ? 'Complete (instrumental work)'
        : normalizedMusic > 0
          ? 'Instrumental work – music splits pending completion'
          : 'Instrumental work – music splits not recorded';
    } else if (hasOver) {
      statusLabel = 'Overallocated – revise immediately';
    } else if (hasUnder && hasEntries) {
      statusLabel = 'Incomplete – temporary split';
    } else if (hasEntries) {
      statusLabel = 'Complete';
    } else {
      statusLabel = 'No allocations recorded';
    }

    return {
      lyricsShare: normalizedLyrics,
      musicShare: normalizedMusic,
      combinedShare,
      lyricsCount: lyricSplits.length,
      musicCount: musicSplits.length,
      statusLabel,
      isIncomplete: lyricsApplicable
        ? hasEntries && hasUnder && !hasOver
        : normalizedMusic > 0 && normalizedMusic < 100,
      lyricsApplicable,
    };
  }

  private buildNeighbouringSummary(neighbouringSplits: WorkSplitRow[]) {
    const totalShare = neighbouringSplits.reduce((sum, split) => sum + this.toNumber(split), 0);
    const tolerance = 0.01;
    const state = totalShare > 100 + tolerance ? 'over' : totalShare >= 100 - tolerance ? 'complete' : 'under';
    const statusLabel = state === 'over'
      ? 'Overallocated – revise immediately'
      : state === 'under' && neighbouringSplits.length > 0
        ? 'Incomplete – temporary split'
        : neighbouringSplits.length > 0
          ? 'Complete'
          : 'No allocations recorded';
    return {
      totalShare,
      count: neighbouringSplits.length,
      statusLabel,
      isIncomplete: neighbouringSplits.length > 0 && state === 'under',
    };
  }

  private buildIPRows(ipSplits: WorkSplitRow[]): Array<[string, string, string, string, string]> {
    return ipSplits.map(split => {
      const holder = split.rights_holder as RightsHolder | null | undefined;
      const holderName = this.getRightsHolderName(holder);
      const role = this.formatRightsHolderKind(holder?.kind) || (split.split_type === 'lyrics' ? 'Lyricist' : 'Composer');
      const splitLabel = split.split_type === 'lyrics' ? 'Lyrics' : 'Music';
      const share = `${this.toNumber(split).toFixed(2)}%`;
      const detailParts = [
        this.buildContributionDetail(split),
        this.buildContactSummary(holder),
        this.formatRightsHolderAIDisclosure(holder?.ai_disclosure),
        split.notes ? `Notes: ${split.notes}` : '',
      ].filter(Boolean);

      return [holderName, role, splitLabel, share, detailParts.join(' • ') || '—'];
    });
  }

  private buildNeighbouringRows(neighbouringSplits: WorkSplitRow[]): Array<[string, string, string, string, string]> {
    return neighbouringSplits.map(split => {
      const holder = split.rights_holder as RightsHolder | null | undefined;
      const holderName = this.getRightsHolderName(holder);
      const role = this.formatRightsHolderKind(holder?.kind) || 'Performer';
      const splitLabel = 'Neighbouring';
      const share = `${this.toNumber(split).toFixed(2)}%`;
      const detailParts = [
        split.roles && split.roles.length ? `Roles: ${split.roles.join(', ')}` : '',
        this.buildContactSummary(holder),
        this.formatRightsHolderAIDisclosure(holder?.ai_disclosure),
        split.notes ? `Notes: ${split.notes}` : '',
      ].filter(Boolean);

      return [holderName, role, splitLabel, share, detailParts.join(' • ') || '—'];
    });
  }

  private collectUniqueHolders(rows: WorkSplitRow[]): RightsHolder[] {
    const map = new Map<string, RightsHolder>();

    rows.forEach(row => {
      const holder = row.rights_holder as RightsHolder | null | undefined;
      if (holder?.id && !map.has(holder.id)) {
        map.set(holder.id, holder);
      }
    });

    return Array.from(map.values());
  }

  private createProtocolFilename(work: Work): string {
    const title = work.work_title?.trim().toLowerCase() || 'untitled-work';
    const slug = title
      .replace(/[^a-z0-9]+/g, '-')
      .replace(/^-+|-+$/g, '')
      .slice(0, 80);

    return `protocol-${slug || 'work'}.pdf`;
  }

  private toNumber(split: WorkSplitRow): number {
    return Number(split.ownership_percentage ?? split.percentage ?? 0);
  }

  private normalizeShare(value: number): number {
    if (!Number.isFinite(value)) {
      return 0;
    }

    return Math.max(0, Math.min(value, 100));
  }

  private safeText(value: string): string {
    return value?.toString().trim() || '';
  }

  private buildLanguageSummary(work: Work): { primary: string; secondary: string; combined: string } {
    const primaryNames = this.extractLanguageNames(work.primary_languages);
    const secondaryNames = this.extractLanguageNames(work.secondary_languages);
    const combinedNames = [...primaryNames];

    const pushUnique = (value: string) => {
      const trimmed = value.trim();
      if (!trimmed) {
        return;
      }
      const key = trimmed.toLowerCase();
      if (!combinedNames.some(existing => existing.toLowerCase() === key)) {
        combinedNames.push(trimmed);
      }
    };

    secondaryNames.forEach(pushUnique);
    this.sanitizeLanguageList(work.languages).forEach(pushUnique);

    return {
      primary: this.formatList(primaryNames),
      secondary: this.formatList(secondaryNames),
      combined: this.formatList(combinedNames),
    };
  }

  private extractLanguageNames(list?: WorkLanguageSelection[] | null): string[] {
    if (!list || !list.length) {
      return [];
    }

    const names: string[] = [];
    const seen = new Set<string>();

    list.forEach(selection => {
      const name = selection?.language?.trim();
      if (!name) {
        return;
      }
      const key = name.toLowerCase();
      if (!seen.has(key)) {
        seen.add(key);
        names.push(name);
      }
    });

    return names;
  }

  private sanitizeLanguageList(list?: string[] | null): string[] {
    if (!list || !list.length) {
      return [];
    }

    const names: string[] = [];
    const seen = new Set<string>();

    list.forEach(entry => {
      const name = entry?.toString().trim();
      if (!name) {
        return;
      }
      const key = name.toLowerCase();
      if (!seen.has(key)) {
        seen.add(key);
        names.push(name);
      }
    });

    return names;
  }

  private formatList(items?: string[]): string {
    if (!items || !items.length) {
      return '—';
    }

    return items.join(', ');
  }

  private formatDate(value?: string): string {
    if (!value) {
      return '—';
    }

    const date = new Date(value);
    if (Number.isNaN(date.getTime())) {
      return value;
    }

    return date.toLocaleDateString();
  }

  private formatDuration(seconds?: number): string {
    if (!seconds || seconds <= 0) {
      return '—';
    }

    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return `${mins}m ${secs.toString().padStart(2, '0')}s`;
  }

  private formatStatus(status?: Work['status']): string {
    if (!status) {
      return '—';
    }

    return status.charAt(0).toUpperCase() + status.slice(1);
  }

  private formatWorkType(type?: Work['work_type']): string {
    if (!type) {
      return 'Standard';
    }

    const map: Record<Work['work_type'], string> = {
      standard: 'Standard',
      instrumental: 'Instrumental',
      remix: 'Remix',
    };

    return map[type] ?? this.safeText(type);
  }

  private formatBoolean(value?: boolean | null): string {
    if (value === undefined || value === null) {
      return '—';
    }

    return value ? 'Yes' : 'No';
  }

  private formatSectionLabel(section: string): string {
    const labels: Record<string, string> = {
      ip: 'Intellectual Property',
      mixing: 'Mixing',
      mastering: 'Mastering',
      session_musicians: 'Session Musicians',
      visuals: 'Visuals',
    };

    return labels[section] || section;
  }

  private formatCreationType(type: string): string {
    const map: Record<string, string> = {
      human: 'Human Generated',
      ai_assisted: 'AI Assisted',
      ai_generated: 'AI Generated',
    };

    return map[type] || type;
  }

  private buildContactSummary(holder?: RightsHolder | null): string {
    if (!holder) {
      return '';
    }

    const parts: string[] = [];

    if (holder.email) {
      parts.push(`Email: ${holder.email}`);
    }

    if (holder.cmo_pro) {
      parts.push(`PRO: ${holder.cmo_pro}`);
    }

    if (holder.ipi_number) {
      parts.push(`IPI: ${holder.ipi_number}`);
    }

    return parts.join(' • ');
  }

  private buildContributionDetail(split: WorkSplitRow): string {
    if (split.split_type !== 'music' || !split.contribution_types) {
      return '';
    }

    const flags: string[] = [];

    if (split.contribution_types.melody) {
      flags.push('Melody');
    }

    if (split.contribution_types.harmony) {
      flags.push('Harmony');
    }

    if (split.contribution_types.arrangement) {
      flags.push('Arrangement');
    }

    return flags.length ? `Contributions: ${flags.join(', ')}` : '';
  }

  private formatRightsHolderKind(kind?: string): string {
    if (!kind) {
      return '';
    }

    const map: Record<string, string> = {
      author: 'Lyricist',
      composer: 'Composer',
      artist: 'Artist',
      producer: 'Producer',
      publisher: 'Publisher',
      label: 'Label',
      arranger: 'Arranger',
      translator: 'Translator',
      engineer: 'Engineer',
      mastering: 'Mastering Engineer',
      other: 'Contributor',
    };

    return map[kind] || kind;
  }

  private formatRightsHolderAIDisclosure(disclosure?: RightsHolder['ai_disclosure']): string {
    if (!disclosure) {
      return '';
    }

    const label = this.formatCreationType(disclosure.creation_type);
    const parts = [`AI: ${label}`];

    if (disclosure.ai_tool) {
      parts.push(`Tool: ${disclosure.ai_tool}`);
    }

    if (disclosure.notes) {
      parts.push(disclosure.notes);
    }

    return parts.join(' – ');
  }

  private ensureNicknamePrefix(nickname: string): string {
    if (!nickname) {
      return nickname;
    }

    return nickname.startsWith('@') ? nickname : `@${nickname}`;
  }

  private getRightsHolderName(holder: any): string {
    if (!holder) {
      return 'Unknown';
    }

    const nickname = holder.nickname ? this.ensureNicknamePrefix(holder.nickname) : null;
    if (nickname) {
      return nickname;
    }

    if (holder.display_name) {
      return holder.display_name;
    }

    if (holder.type === 'person') {
      const legacy = `${holder.first_name || ''} ${holder.last_name || ''}`.trim();
      if (legacy) {
        return legacy;
      }
    }

    return holder.organization_name || holder.company_name || 'Unknown rights holder';
  }
}
